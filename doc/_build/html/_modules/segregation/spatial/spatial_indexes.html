<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>segregation.spatial.spatial_indexes &#8212; segregation v1.0.6 Manual</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pysal-styles.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          segregation</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0.6</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#aspatial-indices">Aspatial Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-indices">Spatial Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#multigroup-indices">Multigroup Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#profile-wrappers">Profile Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#inference-wrappers">Inference Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#decomposition">Decomposition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for segregation.spatial.spatial_indexes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spatial based Segregation Metrics</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Renan X. Cortes &lt;renanc@ucr.edu&gt;, Sergio J. Rey &lt;sergio.rey@ucr.edu&gt; and Elijah Knaap &lt;elijah.knaap@ucr.edu&gt;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">libpysal</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">libpysal.weights</span> <span class="k">import</span> <span class="n">Queen</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">inf</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">manhattan_distances</span><span class="p">,</span> <span class="n">euclidean_distances</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="k">import</span> <span class="n">shift</span>

<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="k">import</span> <span class="n">floyd_warshall</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">csr_matrix</span>

<span class="kn">from</span> <span class="nn">segregation.util.util</span> <span class="k">import</span> <span class="n">_return_length_weighted_w</span>
<span class="kn">from</span> <span class="nn">segregation.aspatial.aspatial_indexes</span> <span class="k">import</span> <span class="n">_dissim</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;Spatial_Prox_Prof&#39;</span><span class="p">,</span> <span class="s1">&#39;Spatial_Dissim&#39;</span><span class="p">,</span> <span class="s1">&#39;Boundary_Spatial_Dissim&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Perimeter_Area_Ratio_Spatial_Dissim&#39;</span><span class="p">,</span> <span class="s1">&#39;Spatial_Isolation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Spatial_Exposure&#39;</span><span class="p">,</span> <span class="s1">&#39;Spatial_Proximity&#39;</span><span class="p">,</span> <span class="s1">&#39;Absolute_Clustering&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Relative_Clustering&#39;</span><span class="p">,</span> <span class="s1">&#39;Delta&#39;</span><span class="p">,</span> <span class="s1">&#39;Absolute_Concentration&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Relative_Concentration&#39;</span><span class="p">,</span> <span class="s1">&#39;Absolute_Centralization&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Relative_Centralization&#39;</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">_spatial_prox_profile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity Profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    m             : int</span>
<span class="sd">                    a numeric value indicating the number of thresholds to be used. Default value is 1000. </span>
<span class="sd">                    A large value of m creates a smoother-looking graph and a more precise spatial proximity profile value but slows down the calculation speed.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Hong, Seong-Yun, and Yukio Sadahiro. &quot;Measuring geographic segregation: a graph-based approach.&quot; Journal of Geographical Systems 16.2 (2014): 211-231.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`hong2014measuring`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;m must be a string.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;m must be greater than 1.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Create the shortest distance path between two pair of units using Shimbel matrix. This step was well discussed in https://github.com/pysal/segregation/issues/5.</span>
    <span class="n">w_libpysal</span> <span class="o">=</span> <span class="n">Queen</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">w_libpysal</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">floyd_warshall</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculate_etat</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">g_t_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="kc">False</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">g_t_i</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sub_delta_ij</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="n">g_t_i</span><span class="p">,:][:,</span><span class="n">g_t_i</span><span class="p">]</span>  <span class="c1"># i and j only varies in the units subset within the threshold in eta_t of Hong (2014).</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">sub_delta_ij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">eta_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">den</span>
        <span class="k">return</span> <span class="n">eta_t</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">calculate_etat</span><span class="p">,</span> <span class="n">grid</span><span class="p">)))</span>
    <span class="n">aux</span><span class="p">[</span><span class="n">aux</span> <span class="o">==</span> <span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">aux</span><span class="p">[</span><span class="n">aux</span> <span class="o">==</span> <span class="o">-</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">curve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">SPP</span> <span class="o">=</span> <span class="p">((</span><span class="n">threshold</span> <span class="o">-</span> <span class="p">((</span><span class="n">curve</span><span class="p">[</span><span class="n">grid</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">m</span> <span class="o">-</span>
                         <span class="p">(</span><span class="n">curve</span><span class="p">[</span><span class="n">grid</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">m</span><span class="p">))</span> <span class="o">/</span>
           <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SPP</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">curve</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Spatial_Prox_Prof"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Prox_Prof.html#segregation.spatial.Spatial_Prox_Prof">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Prox_Prof</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity Profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    m             : int</span>
<span class="sd">                    a numeric value indicating the number of thresholds to be used. Default value is 1000. </span>
<span class="sd">                    A large value of m creates a smoother-looking graph and a more precise spatial proximity profile value but slows down the calculation speed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Profile Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the spatial proximity profile (SPP) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Spatial_Prox_Prof</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index = Spatial_Prox_Prof(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index.statistic</span>
<span class="sd">    0.11217269612149207</span>
<span class="sd">    </span>
<span class="sd">    You can plot the profile curve with the plot method.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index.plot()</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Hong, Seong-Yun, and Yukio Sadahiro. &quot;Measuring geographic segregation: a graph-based approach.&quot; Journal of Geographical Systems 16.2 (2014): 211-231.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`hong2014measuring`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Prox_Prof.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Prox_Prof.html#segregation.spatial.Spatial_Prox_Prof.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_prox_profile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curve</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_prox_profile</span></div>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Spatial Proximity Profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method relies on importing `matplotlib`&#39;</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curve</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span></div>


<span class="k">def</span> <span class="nf">_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">group_pop_var</span><span class="p">,</span>
                    <span class="n">total_pop_var</span><span class="p">,</span>
                    <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    w             : W</span>
<span class="sd">                    A PySAL weights object. If not provided, Queen contiguity matrix is used.</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default with row standardization.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Morrill, R. L. (1991) &quot;On the Measure of Geographic Segregation&quot;. Geography Research Forum.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morrill1991measure`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w_object</span> <span class="o">=</span> <span class="n">Queen</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_object</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">w_object</span><span class="p">),</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;w is not a PySAL weights object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">w_object</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">w_object</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">cij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Inspired in (second solution): https://stackoverflow.com/questions/22720864/efficiently-calculating-a-euclidean-distance-matrix-using-numpy</span>
    <span class="c1"># Distance Matrix</span>
    <span class="n">abs_dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span>

    <span class="c1"># manhattan_distances used to compute absolute distances</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">abs_dist</span><span class="p">,</span> <span class="n">cij</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">SD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="n">SD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Spatial_Dissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Dissim.html#segregation.spatial.Spatial_Dissim">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Dissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    w             : W</span>
<span class="sd">                    A PySAL weights object. If not provided, Queen contiguity matrix is used.</span>
<span class="sd">    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default with row standardization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.   </span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of spatial dissimilarity (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset. The neighborhood contiguity matrix is used.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Spatial_Dissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.2864885055405311</span>
<span class="sd">        </span>
<span class="sd">    To use different neighborhood matrices:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; from libpysal.weights import Rook, KNN</span>
<span class="sd">    </span>
<span class="sd">    Assuming K-nearest neighbors with k = 4</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; knn = KNN.from_dataframe(gdf, k=4)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;, w = knn)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.28544347200877285</span>
<span class="sd">    </span>
<span class="sd">    Assuming Rook contiguity neighborhood</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; roo = Rook.from_dataframe(gdf)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;, w = roo)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.2866269198707091</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Morrill, R. L. (1991) &quot;On the Measure of Geographic Segregation&quot;. Geography Research Forum.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morrill1991measure`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Dissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Dissim.html#segregation.spatial.Spatial_Dissim.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span>
                              <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_dissim</span></div></div>


<span class="k">def</span> <span class="nf">_boundary_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">group_pop_var</span><span class="p">,</span>
                             <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Boundary Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default without row standardization. That is, directly with border length.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Boundary Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The formula is based on Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">    </span>
<span class="sd">    Original paper by Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`hong2014implementing` and :cite:`wong1993spatial`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
        <span class="n">pi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">cij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># manhattan_distances used to compute absolute distances</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">manhattan_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pi&#39;</span><span class="p">]]),</span> <span class="n">cij</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">BSD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="n">BSD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">BSD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Boundary_Spatial_Dissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.Boundary_Spatial_Dissim.html#segregation.spatial.Boundary_Spatial_Dissim">[docs]</a><span class="k">class</span> <span class="nc">Boundary_Spatial_Dissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Boundary Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default without row standardization. That is, directly with border length.</span>
<span class="sd">        </span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Boundary Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">         </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of boundary spatial dissimilarity (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Boundary_Spatial_Dissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; boundary_spatial_dissim_index = Boundary_Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; boundary_spatial_dissim_index.statistic</span>
<span class="sd">    0.28869903953453163</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The formula is based on Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">    </span>
<span class="sd">    Original paper by Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`hong2014implementing` and :cite:`wong1993spatial`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Boundary_Spatial_Dissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Boundary_Spatial_Dissim.html#segregation.spatial.Boundary_Spatial_Dissim.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_boundary_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_boundary_spatial_dissim</span></div></div>


<span class="k">def</span> <span class="nf">_perimeter_area_ratio_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                         <span class="n">group_pop_var</span><span class="p">,</span>
                                         <span class="n">total_pop_var</span><span class="p">,</span>
                                         <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Perimeter/Area Ratio Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for standardisation of the weights matrices. </span>
<span class="sd">                    If True, the values of cij in the formulas gets standardized and the overall sum is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Perimeter/Area Ratio Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Originally based on Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    However, Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    points out that in Wong’s original there is an issue with the formula which is an extra division by 2 in the spatial interaction component.</span>
<span class="sd">    This function follows the formula present in the first Appendix of Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>

<span class="sd">    References: :cite:`wong1993spatial` and :cite:`tivadar2019oasisr`.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
        <span class="n">pi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">peri</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">length</span>
    <span class="n">ai</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span>

    <span class="n">aux_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">))),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">max_pa</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">manhattan_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pi&#39;</span><span class="p">]]),</span> <span class="n">cij</span><span class="p">),</span>
                      <span class="n">aux_sum</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_pa</span>

    <span class="n">PARD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
    <span class="n">PARD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">PARD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Perimeter_Area_Ratio_Spatial_Dissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.Perimeter_Area_Ratio_Spatial_Dissim.html#segregation.spatial.Perimeter_Area_Ratio_Spatial_Dissim">[docs]</a><span class="k">class</span> <span class="nc">Perimeter_Area_Ratio_Spatial_Dissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Perimeter/Area Ratio Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for standardisation of the weights matrices. </span>
<span class="sd">                    If True, the values of cij in the formulas gets standardized and the overall sum is 1.</span>
<span class="sd">        </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Perimeter/Area Ratio Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.      </span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of perimeter/area ratio spatial dissimilarity (PARD) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Perimeter_Area_Ratio_Spatial_Dissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; perimeter_area_ratio_spatial_dissim_index = Perimeter_Area_Ratio_Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; perimeter_area_ratio_spatial_dissim_index.statistic</span>
<span class="sd">    0.31260876347432687</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Originally based on Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    However, Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    points out that in Wong’s original there is an issue with the formula which is an extra division by 2 in the spatial interaction component.</span>
<span class="sd">    This function follows the formula present in the first Appendix of Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`wong1993spatial` and :cite:`tivadar2019oasisr`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Perimeter_Area_Ratio_Spatial_Dissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Perimeter_Area_Ratio_Spatial_Dissim.html#segregation.spatial.Perimeter_Area_Ratio_Spatial_Dissim.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_perimeter_area_ratio_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span>
                                                   <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_perimeter_area_ratio_spatial_dissim</span></div></div>


<span class="k">def</span> <span class="nf">_spatial_isolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                       <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Isolation index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Isolation Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This measure is also called the distance decay isolation. It may be interpreted as the probability that the next person a group member meets anywhere in space is from the same group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span><span class="p">,</span>
            <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span>
        <span class="p">}))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">Pij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">SxPx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span> <span class="o">*</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">t</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SxPx</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Spatial_Isolation"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Isolation.html#segregation.spatial.Spatial_Isolation">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Isolation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Isolation index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Isolation Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the spatial isolation index (SxPx) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Spatial_Isolation</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_isolation_index = Spatial_Isolation(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_isolation_index.statistic</span>
<span class="sd">    0.07214112078134231</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This measure is also called the distance decay isolation. It may be interpreted as the probability that the next person a group member meets anywhere in space is from the same group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Isolation.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Isolation.html#segregation.spatial.Spatial_Isolation.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_isolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                 <span class="n">beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_isolation</span></div></div>


<span class="k">def</span> <span class="nf">_spatial_exposure</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Exposure index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Exposure Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This measure is also called the distance decay exposure. It may be interpreted as the probability that the next person a group member meets anywhere in space is from the other group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span><span class="p">,</span>
            <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span>
        <span class="p">}))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">Pij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">SxPy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SxPy</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Spatial_Exposure"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Exposure.html#segregation.spatial.Spatial_Exposure">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Exposure</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Exposure index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Exposure Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the spatial exposure index (SxPy) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Spatial_Exposure</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_exposure_index = Spatial_Exposure(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_exposure_index.statistic</span>
<span class="sd">    0.9605053172501217</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This measure is also called the distance decay exposure. It may be interpreted as the probability that the next person a group member meets anywhere in space is from the other group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Exposure.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Exposure.html#segregation.spatial.Spatial_Exposure.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_exposure</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                <span class="n">beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_exposure</span></div></div>


<span class="k">def</span> <span class="nf">_spatial_proximity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                       <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">ti</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">,</span>
                       <span class="n">c_lons</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                       <span class="n">c_lats</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;c_lons&#39;</span><span class="p">,</span> <span class="s1">&#39;c_lats&#39;</span><span class="p">]])</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">Pxx</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">X</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Pyy</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Ptt</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ti</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">SP</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">Pxx</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">Pyy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">Ptt</span><span class="p">)</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SP</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Spatial_Proximity"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Proximity.html#segregation.spatial.Spatial_Proximity">[docs]</a><span class="k">class</span> <span class="nc">Spatial_Proximity</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of spatial proximity (SP) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Spatial_Proximity</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_prox_index = Spatial_Proximity(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_prox_index.statistic</span>
<span class="sd">    1.002191883006537</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spatial_Proximity.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Spatial_Proximity.html#segregation.spatial.Spatial_Proximity.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_proximity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                 <span class="n">beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_proximity</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                         <span class="n">group_pop_var</span><span class="p">,</span>
                         <span class="n">total_pop_var</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">c_lons</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                       <span class="n">c_lats</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;c_lons&#39;</span><span class="p">,</span> <span class="s1">&#39;c_lats&#39;</span><span class="p">]])</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">ACL</span> <span class="o">=</span> <span class="p">((((</span><span class="n">x</span><span class="o">/</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">X</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">/</span> \
          <span class="p">((((</span><span class="n">x</span><span class="o">/</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">X</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">ACL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Absolute_Clustering"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Clustering.html#segregation.spatial.Absolute_Clustering">[docs]</a><span class="k">class</span> <span class="nc">Absolute_Clustering</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute clustering measure (ACL) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;trtid10&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;trtid10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_clust_index = Absolute_Clustering(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_clust_index.statistic</span>
<span class="sd">    0.20979814508119624</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Absolute_Clustering.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Clustering.html#segregation.spatial.Absolute_Clustering.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                   <span class="n">beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_clustering</span></div></div>


<span class="k">def</span> <span class="nf">_relative_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                         <span class="n">group_pop_var</span><span class="p">,</span>
                         <span class="n">total_pop_var</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Relative Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">c_lons</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                       <span class="n">c_lats</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;c_lons&#39;</span><span class="p">,</span> <span class="s1">&#39;c_lats&#39;</span><span class="p">]])</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">Pxx</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">X</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Pyy</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">RCL</span> <span class="o">=</span> <span class="n">Pxx</span> <span class="o">/</span> <span class="n">Pyy</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">RCL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Relative_Clustering"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Clustering.html#segregation.spatial.Relative_Clustering">[docs]</a><span class="k">class</span> <span class="nc">Relative_Clustering</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Relative Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative clustering measure (RCL) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Relative_Clustering</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_clust_index = Relative_Clustering(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_clust_index.statistic</span>
<span class="sd">    0.12418089857347714</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Relative_Clustering.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Clustering.html#segregation.spatial.Relative_Clustering.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                   <span class="n">beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_clustering</span></div></div>


<span class="k">def</span> <span class="nf">_delta</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Delta index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Delta Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">DEL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span> <span class="o">-</span> <span class="n">area</span> <span class="o">/</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">DEL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Delta"><a class="viewcode-back" href="../../../generated/segregation.spatial.Delta.html#segregation.spatial.Delta">[docs]</a><span class="k">class</span> <span class="nc">Delta</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Delta index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Delta Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the delta index (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Delta</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; delta_index = Delta(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; delta_index.statistic</span>
<span class="sd">    0.8367330649317353</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Delta.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Delta.html#segregation.spatial.Delta.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_delta</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_delta</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Create the indexes according to the area ordering</span>
    <span class="n">des_ind</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">area</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">des_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">ACO</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span> <span class="p">((((</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">T1</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">/</span> \
          <span class="p">(((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">T2</span><span class="p">)[</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span><span class="o">/</span><span class="n">T1</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">ACO</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Absolute_Concentration"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Concentration.html#segregation.spatial.Absolute_Concentration">[docs]</a><span class="k">class</span> <span class="nc">Absolute_Concentration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute concentration index (ACO) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Absolute_Concentration</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_concentration_index = Absolute_Concentration(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_concentration_index.statistic</span>
<span class="sd">    0.5430616390401855</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Absolute_Concentration.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Concentration.html#segregation.spatial.Absolute_Concentration.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_concentration</span></div></div>


<span class="k">def</span> <span class="nf">_relative_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Relative Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Create the indexes according to the area ordering</span>
    <span class="n">des_ind</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">area</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">des_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">RCO</span> <span class="o">=</span> <span class="p">((((</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">/</span> <span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> \
          <span class="p">((((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])[</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">RCO</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Relative_Concentration"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Concentration.html#segregation.spatial.Relative_Concentration">[docs]</a><span class="k">class</span> <span class="nc">Relative_Concentration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Relative Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">       </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative concentration index (RCO) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Relative_Concentration</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_concentration_index = Relative_Concentration(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_concentration_index.statistic</span>
<span class="sd">    0.5364305924831142</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Relative_Concentration.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Concentration.html#segregation.spatial.Relative_Concentration.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_concentration</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Absolute Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;population_weighted_mean&#39;</span><span class="p">,</span>
                <span class="s1">&#39;largest_population&#39;</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The center string must one of </span><span class="se">\&#39;</span><span class="s1">mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">median</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">population_weighted_mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">largest_population</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lons</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;population_weighted_mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lons</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lats</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;largest_population&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center tuple/list/array must have length 2.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center index must by in the range of data.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">center_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">c_lons</span> <span class="o">-</span> <span class="n">center_lon</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">c_lats</span> <span class="o">-</span> <span class="n">center_lat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">center_dist</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">A</span>

    <span class="n">ACE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">shift</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ai</span><span class="p">)</span> <span class="o">-</span> \
          <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Xi</span> <span class="o">*</span> <span class="n">shift</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="n">center_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ACE</span><span class="p">,</span> <span class="n">core_data</span><span class="p">,</span> <span class="n">center_values</span>


<div class="viewcode-block" id="Absolute_Centralization"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Centralization.html#segregation.spatial.Absolute_Centralization">[docs]</a><span class="k">class</span> <span class="nc">Absolute_Centralization</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Absolute Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute centralization index (ACE) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Absolute_Centralization</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_centralization_index = Absolute_Centralization(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_centralization_index.statistic</span>
<span class="sd">    0.6416113799795511</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Absolute_Centralization.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Absolute_Centralization.html#segregation.spatial.Absolute_Centralization.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">center</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_values</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_centralization</span></div></div>


<span class="k">def</span> <span class="nf">_relative_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Relative Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;population_weighted_mean&#39;</span><span class="p">,</span>
                <span class="s1">&#39;largest_population&#39;</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The center string must one of </span><span class="se">\&#39;</span><span class="s1">mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">median</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">population_weighted_mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">largest_population</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lons</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;population_weighted_mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lons</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lats</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;largest_population&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center tuple/list/array must have length 2.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center index must by in the range of data.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">center_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">c_lons</span> <span class="o">-</span> <span class="n">center_lon</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">c_lats</span> <span class="o">-</span> <span class="n">center_lat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">center_dist</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">Yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">Y</span>

    <span class="n">RCE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">shift</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span> <span class="o">*</span> <span class="n">Yi</span><span class="p">)</span> <span class="o">-</span> \
          <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Xi</span> <span class="o">*</span> <span class="n">shift</span><span class="p">(</span><span class="n">Yi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="n">center_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">RCE</span><span class="p">,</span> <span class="n">core_data</span><span class="p">,</span> <span class="n">center_values</span>


<div class="viewcode-block" id="Relative_Centralization"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Centralization.html#segregation.spatial.Relative_Centralization">[docs]</a><span class="k">class</span> <span class="nc">Relative_Centralization</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Relative Centralization Index</span>
<span class="sd">            </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative centralization index (RCE) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Relative_Centralization</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/tree/master/geosnap/data.</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_centralization_index = Relative_Centralization(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_centralization_index.statistic</span>
<span class="sd">    0.18550429720565376</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Relative_Centralization.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Relative_Centralization.html#segregation.spatial.Relative_Centralization.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">center</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_values</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_centralization</span></div></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>