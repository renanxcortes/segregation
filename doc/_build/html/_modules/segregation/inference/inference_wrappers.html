<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>segregation.inference.inference_wrappers &#8212; segregation v1.0.6 Manual</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pysal-styles.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          segregation</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0.6</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#aspatial-indices">Aspatial Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#spatial-indices">Spatial Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#multigroup-indices">Multigroup Indices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#profile-wrappers">Profile Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#inference-wrappers">Inference Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#decomposition">Decomposition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for segregation.inference.inference_wrappers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Inference Wrappers for Segregation measures</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Renan X. Cortes &lt;renanc@ucr.edu&gt; Sergio J. Rey &lt;sergio.rey@ucr.edu&gt; and Elijah Knaap &lt;elijah.knaap@ucr.edu&gt;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Infer_Segregation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Compare_Segregation&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_infer_segregation</span><span class="p">(</span><span class="n">seg_class</span><span class="p">,</span> <span class="n">iterations_under_null</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">null_approach</span> <span class="o">=</span> <span class="s2">&quot;systematic&quot;</span><span class="p">,</span> <span class="n">two_tailed</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform inference for a single segregation measure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    seg_class                    : a PySAL segregation object</span>
<span class="sd">    </span>
<span class="sd">    iterations_under_null        : number of iterations under null hyphothesis</span>
<span class="sd">    </span>
<span class="sd">    null_approach : argument that specifies which type of null hypothesis the inference will iterate.</span>
<span class="sd">    </span>
<span class="sd">        &quot;systematic&quot;             : assumes that every group has the same probability with restricted conditional probabilities p_0_j = p_1_j = p_j = n_j/n (multinomial distribution).</span>
<span class="sd">        &quot;bootstrap&quot;              : generates bootstrap replications of the units with replacement of the same size of the original data.</span>
<span class="sd">        &quot;evenness&quot;               : assumes that each spatial unit has the same global probability of drawing elements from the minority group of the fixed total unit population (binomial distribution).</span>
<span class="sd">        </span>
<span class="sd">        &quot;permutation&quot;            : randomly allocates the units over space keeping the original values.</span>
<span class="sd">        </span>
<span class="sd">        &quot;systematic_permutation&quot; : assumes absence of systematic segregation and randomly allocates the units over space.</span>
<span class="sd">        &quot;even_permutation&quot;       : assumes the same global probability of drawning elements from the minority group in each spatial unit and randomly allocates the units over space.</span>
<span class="sd">    </span>
<span class="sd">    two_tailed    : boolean</span>
<span class="sd">                    If True, p_value is two-tailed. Otherwise, it is right one-tailed.</span>
<span class="sd">    </span>
<span class="sd">    **kwargs      : customizable parameters to pass to the segregation measures. Usually they need to be the same input that the seg_class was built.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    p_value     : float</span>
<span class="sd">                  Pseudo One or Two-Tailed p-value estimated from the simulations</span>
<span class="sd">    </span>
<span class="sd">    est_sim     : numpy array</span>
<span class="sd">                  Estimates of the segregation measure under the null hypothesis</span>
<span class="sd">                  </span>
<span class="sd">    statistic   : float</span>
<span class="sd">                  The point estimation of the segregation measure that is under test</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The one-tailed p_value attribute might not be appropriate for some measures, as the two-tailed. Therefore, it is better to rely on the est_sim attribute.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">null_approach</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;systematic&#39;</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">,</span> <span class="s1">&#39;evenness&#39;</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="s1">&#39;systematic_permutation&#39;</span><span class="p">,</span> <span class="s1">&#39;even_permutation&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;null_approach must one of </span><span class="se">\&#39;</span><span class="s1">systematic</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">bootstrap</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">evenness</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">permutation</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">systematic_permutation</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">even_permutation</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">two_tailed</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;two_tailed is not a boolean object&#39;</span><span class="p">)</span>
    
    <span class="n">point_estimation</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">statistic</span>
    <span class="n">data</span>             <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">core_data</span>
    
    <span class="n">aux</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seg_class</span><span class="p">))</span>
    <span class="n">_class_name</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">aux</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># &#39;rfind&#39; finds the last occurence of a pattern in a string</span>

    
    <span class="c1">##############</span>
    <span class="c1"># SYSTEMATIC #</span>
    <span class="c1">##############</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;systematic&quot;</span><span class="p">):</span>
    
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;other_group_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
        <span class="n">p_j</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Group 0: minority group</span>
        <span class="n">p0_i</span> <span class="o">=</span> <span class="n">p_j</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sim0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">p0_i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">iterations_under_null</span><span class="p">)</span>

        <span class="c1"># Group 1: complement group</span>
        <span class="n">p1_i</span> <span class="o">=</span> <span class="n">p_j</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;other_group_pop&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sim1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">p1_i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">iterations_under_null</span><span class="p">)</span>

        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            <span class="n">data_aux</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;simul_group&#39;</span><span class="p">:</span> <span class="n">sim0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">sim0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_aux</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
                <span class="n">df_aux</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_aux</span><span class="p">)</span>
                <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
                
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;simul_group&#39;</span><span class="p">,</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#############</span>
    <span class="c1"># BOOTSTRAP #</span>
    <span class="c1">#############</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;bootstrap&quot;</span><span class="p">):</span>
        
        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            
            <span class="n">sample_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sample_index</span><span class="p">]</span>
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">############</span>
    <span class="c1"># EVENNESS #</span>
    <span class="c1">############</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;evenness&quot;</span><span class="p">):</span>
        
        <span class="n">p_null</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]),</span> 
                                     <span class="n">p</span> <span class="o">=</span> <span class="n">p_null</span><span class="p">)</span>
            <span class="n">data_aux</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;simul_group&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_aux</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
                <span class="n">df_aux</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_aux</span><span class="p">)</span>
                <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;simul_group&#39;</span><span class="p">,</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">###############</span>
    <span class="c1"># PERMUTATION #</span>
    <span class="c1">###############</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;permutation&quot;</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;data is not a GeoDataFrame, therefore, this null approach does not apply.&#39;</span><span class="p">)</span>
        
        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">##########################</span>
    <span class="c1"># SYSTEMATIC PERMUTATION #</span>
    <span class="c1">##########################</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;systematic_permutation&quot;</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;data is not a GeoDataFrame, therefore, this null approach does not apply.&#39;</span><span class="p">)</span>
    
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;other_group_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
        <span class="n">p_j</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Group 0: minority group</span>
        <span class="n">p0_i</span> <span class="o">=</span> <span class="n">p_j</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sim0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">p0_i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">iterations_under_null</span><span class="p">)</span>

        <span class="c1"># Group 1: complement group</span>
        <span class="n">p1_i</span> <span class="o">=</span> <span class="n">p_j</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;other_group_pop&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sim1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">p1_i</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">iterations_under_null</span><span class="p">)</span>

        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            <span class="n">data_aux</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;simul_group&#39;</span><span class="p">:</span> <span class="n">sim0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">sim0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_aux</span><span class="p">)</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_aux</span><span class="p">)</span>
            <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">df_aux</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">df_aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">df_aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;simul_group&#39;</span><span class="p">,</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">########################</span>
    <span class="c1"># EVENNESS PERMUTATION #</span>
    <span class="c1">########################</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;even_permutation&quot;</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;data is not a GeoDataFrame, therefore, this null approach does not apply.&#39;</span><span class="p">)</span>
        
        <span class="n">p_null</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        
        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]),</span> 
                                     <span class="n">p</span> <span class="o">=</span> <span class="n">p_null</span><span class="p">)</span>
            <span class="n">data_aux</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;simul_group&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_aux</span><span class="p">)</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_aux</span><span class="p">)</span>
            <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
            <span class="n">df_aux</span> <span class="o">=</span> <span class="n">df_aux</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">df_aux</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">df_aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">df_aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
            <span class="n">Estimates_Stars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_class</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">df_aux</span><span class="p">,</span> <span class="s1">&#39;simul_group&#39;</span><span class="p">,</span> <span class="s1">&#39;simul_tot&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="c1"># Check and, if the case, remove iterations_under_null that resulted in nan or infinite values</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Estimates_Stars</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Estimates_Stars</span><span class="p">))):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some estimates resulted in NaN or infinite values for estimations under null hypothesis. These values will be removed for the final results.&#39;</span><span class="p">)</span>
        <span class="n">Estimates_Stars</span> <span class="o">=</span> <span class="n">Estimates_Stars</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Estimates_Stars</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Estimates_Stars</span><span class="p">))]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">two_tailed</span><span class="p">:</span>
        <span class="n">p_value</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Estimates_Stars</span> <span class="o">&gt;</span> <span class="n">point_estimation</span><span class="p">)</span> <span class="o">/</span> <span class="n">iterations_under_null</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aux1</span> <span class="o">=</span> <span class="p">(</span><span class="n">point_estimation</span> <span class="o">&lt;</span> <span class="n">Estimates_Stars</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">aux2</span> <span class="o">=</span> <span class="p">(</span><span class="n">point_estimation</span> <span class="o">&gt;</span> <span class="n">Estimates_Stars</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">aux1</span><span class="p">,</span> <span class="n">aux2</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">Estimates_Stars</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">Estimates_Stars</span><span class="p">,</span> <span class="n">point_estimation</span><span class="p">,</span> <span class="n">_class_name</span>



<div class="viewcode-block" id="Infer_Segregation"><a class="viewcode-back" href="../../../generated/segregation.inference.Infer_Segregation.html#segregation.inference.Infer_Segregation">[docs]</a><span class="k">class</span> <span class="nc">Infer_Segregation</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform inference for a single segregation measure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    seg_class                    : a PySAL segregation object</span>
<span class="sd">    </span>
<span class="sd">    iterations_under_null        : number of iterations under null hyphothesis</span>
<span class="sd">    </span>
<span class="sd">    null_approach : argument that specifies which type of null hypothesis the inference will iterate.</span>
<span class="sd">    </span>
<span class="sd">        &quot;systematic&quot;             : assumes that every group has the same probability with restricted conditional probabilities p_0_j = p_1_j = p_j = n_j/n (multinomial distribution).</span>
<span class="sd">        &quot;bootstrap&quot;              : generates bootstrap replications of the units with replacement of the same size of the original data.</span>
<span class="sd">        &quot;evenness&quot;               : assumes that each spatial unit has the same global probability of drawing elements from the minority group of the fixed total unit population (binomial distribution).</span>
<span class="sd">        </span>
<span class="sd">        &quot;permutation&quot;            : randomly allocates the units over space keeping the original values.</span>
<span class="sd">        </span>
<span class="sd">        &quot;systematic_permutation&quot; : assumes absence of systematic segregation and randomly allocates the units over space.</span>
<span class="sd">        &quot;even_permutation&quot;       : assumes the same global probability of drawning elements from the minority group in each spatial unit and randomly allocates the units over space.</span>
<span class="sd">    </span>
<span class="sd">    two_tailed    : boolean</span>
<span class="sd">                    If True, p_value is two-tailed. Otherwise, it is right one-tailed.</span>
<span class="sd">    </span>
<span class="sd">    **kwargs      : customizable parameters to pass to the segregation measures. Usually they need to be the same input that the seg_class was built.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    p_value     : float</span>
<span class="sd">                  Pseudo One or Two-Tailed p-value estimated from the simulations</span>
<span class="sd">    </span>
<span class="sd">    est_sim     : numpy array</span>
<span class="sd">                  Estimates of the segregation measure under the null hypothesis</span>
<span class="sd">                  </span>
<span class="sd">    statistic   : float</span>
<span class="sd">                  The point estimation of the segregation measure that is under test</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The one-tailed p_value attribute might not be appropriate for some measures, as the two-tailed. Therefore, it is better to rely on the est_sim attribute.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Several examples can be found here https://github.com/pysal/segregation/blob/master/notebooks/inference_wrappers_example.ipynb.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Infer_Segregation.__init__"><a class="viewcode-back" href="../../../generated/segregation.inference.Infer_Segregation.html#segregation.inference.Infer_Segregation.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_class</span><span class="p">,</span> <span class="n">iterations_under_null</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">null_approach</span> <span class="o">=</span> <span class="s2">&quot;systematic&quot;</span><span class="p">,</span> <span class="n">two_tailed</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="n">aux</span> <span class="o">=</span> <span class="n">_infer_segregation</span><span class="p">(</span><span class="n">seg_class</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">,</span> <span class="n">null_approach</span><span class="p">,</span> <span class="n">two_tailed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_value</span>      <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_sim</span>      <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span>    <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_name</span>  <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></div>
        
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Infer_Segregation class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method relies on importing `matplotlib` and `seaborn`&#39;</span><span class="p">)</span>
    
        <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_sim</span><span class="p">,</span> 
                     <span class="n">hist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                     <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;darkblue&#39;</span><span class="p">,</span> 
                     <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">},</span>
                     <span class="n">kde_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> (Value = </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_name</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    
    
    
    
    
    
    
    
<span class="k">def</span> <span class="nf">_compare_segregation</span><span class="p">(</span><span class="n">seg_class_1</span><span class="p">,</span> <span class="n">seg_class_2</span><span class="p">,</span> <span class="n">iterations_under_null</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">null_approach</span> <span class="o">=</span> <span class="s2">&quot;random_label&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform inference comparison for a two segregation measures</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    seg_class_1           : a PySAL segregation object to be compared to seg_class_2</span>
<span class="sd">    </span>
<span class="sd">    seg_class_2           : a PySAL segregation object to be compared to seg_class_1</span>
<span class="sd">    </span>
<span class="sd">    iterations_under_null : number of iterations under null hyphothesis</span>
<span class="sd">    </span>
<span class="sd">    null_approach: argument that specifies which type of null hypothesis the inference will iterate.</span>
<span class="sd">    </span>
<span class="sd">        &quot;random_label&quot;               : random label the data in each iteration</span>
<span class="sd">        </span>
<span class="sd">        &quot;counterfactual_composition&quot; : randomizes the number of minority population according to both cumulative distribution function of a variable that represents the composition of the minority group. The composition is the division of the minority population of unit i divided by total population of tract i.</span>

<span class="sd">        &quot;counterfactual_share&quot; : randomizes the number of minority population and total population according to both cumulative distribution function of a variable that represents the share of the minority group. The share is the division of the minority population of unit i divided by total population of minority population.</span>

<span class="sd">    **kwargs : customizable parameters to pass to the segregation measures. Usually they need to be the same as both seg_class_1 and seg_class_2  was built.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    p_value        : float</span>
<span class="sd">                     Two-Tailed p-value</span>
<span class="sd">    </span>
<span class="sd">    est_sim        : numpy array</span>
<span class="sd">                     Estimates of the segregation measure differences under the null hypothesis</span>
<span class="sd">                  </span>
<span class="sd">    est_point_diff : float</span>
<span class="sd">                     Point estimation of the difference between the segregation measures</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function performs inference to compare two segregation measures. This can be either two measures of the same locations in two different points in time or it can be two different locations at the same point in time.</span>
<span class="sd">    </span>
<span class="sd">    The null hypothesis is H0: Segregation_1 is not different than Segregation_2.</span>
<span class="sd">    </span>
<span class="sd">    Based on Rey, Sergio J., and Myrna L. Sastré-Gutiérrez. &quot;Interregional inequality dynamics in Mexico.&quot; Spatial Economic Analysis 5.3 (2010): 277-298.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">null_approach</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;random_label&#39;</span><span class="p">,</span> <span class="s1">&#39;counterfactual_composition&#39;</span><span class="p">,</span> <span class="s1">&#39;counterfactual_share&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;null_approach must one of </span><span class="se">\&#39;</span><span class="s1">random_label</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">counterfactual_composition</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">counterfactual_share</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">if</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seg_class_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">seg_class_2</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;seg_class_1 and seg_class_2 must be the same type/class.&#39;</span><span class="p">)</span>
    
    <span class="n">point_estimation</span> <span class="o">=</span> <span class="n">seg_class_1</span><span class="o">.</span><span class="n">statistic</span> <span class="o">-</span> <span class="n">seg_class_2</span><span class="o">.</span><span class="n">statistic</span>
    
    <span class="n">aux</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">seg_class_1</span><span class="p">))</span>
    <span class="n">_class_name</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">aux</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># &#39;rfind&#39; finds the last occurence of a pattern in a string</span>

    <span class="n">data_1</span> <span class="o">=</span> <span class="n">seg_class_1</span><span class="o">.</span><span class="n">core_data</span>
    <span class="n">data_2</span> <span class="o">=</span> <span class="n">seg_class_2</span><span class="o">.</span><span class="n">core_data</span>
    
    <span class="c1"># This step is just to make sure the each frequecy column is integer for the approaches and from the same type in order to stack them for the random data approach</span>
    <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">est_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)</span>
    
    
    
    <span class="c1">################</span>
    <span class="c1"># RANDOM LABEL #</span>
    <span class="c1">################</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;random_label&quot;</span><span class="p">):</span>

        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;grouping_variable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Group_1&#39;</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;grouping_variable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Group_2&#39;</span>

        <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>
            
            <span class="n">aux_rand</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">stacked_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stacked_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>

            <span class="n">stacked_data</span><span class="p">[</span><span class="s1">&#39;rand_group_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacked_data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">[</span><span class="n">aux_rand</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
            <span class="n">stacked_data</span><span class="p">[</span><span class="s1">&#39;rand_total_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stacked_data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">[</span><span class="n">aux_rand</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span>
            
            <span class="c1"># Dropping variable to avoid confusion in the calculate_segregation function </span>
            <span class="c1"># Building auxiliar data to avoid affecting the next iteration</span>
            <span class="n">stacked_data_aux</span> <span class="o">=</span> <span class="n">stacked_data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="n">stacked_data_1</span> <span class="o">=</span> <span class="n">stacked_data_aux</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stacked_data_aux</span><span class="p">[</span><span class="s1">&#39;grouping_variable&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Group_1&#39;</span><span class="p">]</span>
            <span class="n">stacked_data_2</span> <span class="o">=</span> <span class="n">stacked_data_aux</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stacked_data_aux</span><span class="p">[</span><span class="s1">&#39;grouping_variable&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Group_2&#39;</span><span class="p">]</span>

            <span class="n">simulations_1</span> <span class="o">=</span> <span class="n">seg_class_1</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">stacked_data_1</span><span class="p">,</span> <span class="s1">&#39;rand_group_pop&#39;</span><span class="p">,</span> <span class="s1">&#39;rand_total_pop&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">simulations_2</span> <span class="o">=</span> <span class="n">seg_class_2</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">stacked_data_2</span><span class="p">,</span> <span class="s1">&#39;rand_group_pop&#39;</span><span class="p">,</span> <span class="s1">&#39;rand_total_pop&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">est_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulations_1</span> <span class="o">-</span> <span class="n">simulations_2</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
            

            
            
    <span class="c1">##############################</span>
    <span class="c1"># COUNTERFACTUAL COMPOSITION #</span>
    <span class="c1">##############################</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;counterfactual_composition&quot;</span><span class="p">):</span>

        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span>

        <span class="c1"># Both appends are to force both distribution to have values in all space between 0 and 1</span>
        <span class="n">x_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">])</span>
        <span class="n">y_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_1_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_1_pre</span><span class="p">))</span>

        <span class="n">x_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">])</span>
        <span class="n">y_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_2_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_2_pre</span><span class="p">))</span>

        <span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inverse_cdf_1</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_1</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">inverse_cdf_2</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_2</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Adding the pseudo columns for FIRST spatial context</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">inverse_cdf_2</span><span class="p">)</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_rel&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Adding the pseudo columns for SECOND spatial context</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;rel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_rel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">inverse_cdf_1</span><span class="p">)</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_rel&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>

            <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">))</span>
            <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">])</span>
            
            <span class="c1"># Dropping to avoid confusion in the internal function</span>
            <span class="n">data_1_test</span> <span class="o">=</span> <span class="n">data_1</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="n">simulations_1</span> <span class="o">=</span> <span class="n">seg_class_1</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">data_1_test</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Dropping to avoid confusion in the next iteration</span>
            <span class="n">data_1</span> <span class="o">=</span> <span class="n">data_1</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            

            
            <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">))</span>
            <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">])</span>
            
            <span class="c1"># Dropping to avoid confusion in the internal function</span>
            <span class="n">data_2_test</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="n">simulations_2</span> <span class="o">=</span> <span class="n">seg_class_2</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">data_2_test</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Dropping to avoid confusion in the next iteration</span>
            <span class="n">data_2</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="n">est_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulations_1</span> <span class="o">-</span> <span class="n">simulations_2</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span> 
            
            
            
            
            
            
            
    <span class="c1">########################</span>
    <span class="c1"># COUNTERFACTUAL SHARE #</span>
    <span class="c1">########################</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">null_approach</span> <span class="o">==</span> <span class="s2">&quot;counterfactual_share&quot;</span><span class="p">):</span>

        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
        
        <span class="c1"># Build the share for each group individually</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># Both appends are to force both distribution to have values in all space between 0 and 1</span>
        <span class="n">x_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">])</span>
        <span class="n">y_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_1_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_1_pre</span><span class="p">))</span>

        <span class="n">x_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">])</span>
        <span class="n">y_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_2_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_2_pre</span><span class="p">))</span>

        <span class="n">x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">inverse_cdf_1</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_1</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">inverse_cdf_2</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_2</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>



        <span class="c1"># Both appends are to force both distribution to have values in all space between 0 and 1</span>
        <span class="n">compl_x_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">])</span>
        <span class="n">compl_y_1_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">compl_x_1_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compl_x_1_pre</span><span class="p">))</span>

        <span class="n">compl_x_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">])</span>
        <span class="n">compl_y_2_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">compl_x_2_pre</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">compl_x_2_pre</span><span class="p">))</span>

        <span class="n">compl_x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compl_x_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">compl_y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compl_y_1_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">compl_x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compl_x_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">compl_y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compl_y_2_pre</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">compl_inverse_cdf_1</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">compl_x_1</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">compl_y_1</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">compl_inverse_cdf_2</span><span class="p">(</span><span class="n">pct</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">compl_x_2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">compl_y_2</span> <span class="o">&gt;</span> <span class="n">pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>


        <span class="c1"># Adding the pseudo columns for FIRST spatial context</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">inverse_cdf_2</span><span class="p">)</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_share&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Rescale due to possibility of the summation of the values being grater of lower than 1</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_share&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">compl_inverse_cdf_2</span><span class="p">)</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Rescale due to possibility of the summation of the values being grater of lower than 1</span>
        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_compl_pop_var&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


        <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_total_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_compl_pop_var&#39;</span><span class="p">]</span>




        <span class="c1"># Adding the pseudo columns for SECOND spatial context</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;share&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">inverse_cdf_1</span><span class="p">)</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_share&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_share_pre&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Rescale due to possibility of the summation of the values being grater of lower than 1</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_share&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_cumulative_percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_share&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">)</span> <span class="c1"># It has to be a minus 1 in the rank, in order to avoid 100% percentile in the max</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_cumulative_percentage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">compl_inverse_cdf_1</span><span class="p">)</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share&#39;</span><span class="p">]</span>          <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share_pre&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1"># Rescale due to possibility of the summation of the values being grater of lower than 1</span>
        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_compl_pop_var&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pseudo_share&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;compl_pop_var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


        <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_total_pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_compl_pop_var&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">iterations_under_null</span><span class="p">)):</span>

            <span class="c1"># For this &#39;counterfactual_share&#39; approach, also the group and total population can be swapped during the iterations</span>
            <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_1</span><span class="p">))</span>
            <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">])</span>
            <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">],</span> <span class="n">data_1</span><span class="p">[</span><span class="s1">&#39;pseudo_total_pop&#39;</span><span class="p">])</span>
            
            <span class="c1"># Dropping to avoid confusion in the internal function</span>
            <span class="n">data_1_test</span> <span class="o">=</span> <span class="n">data_1</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="n">simulations_1</span> <span class="o">=</span> <span class="n">seg_class_1</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">data_1_test</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Dropping to avoid confusion in the next iteration</span>
            <span class="n">data_1</span> <span class="o">=</span> <span class="n">data_1</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            

            <span class="c1"># For this &#39;counterfactual_share&#39; approach, also the group and total population can be swapped during the iterations</span>
            <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_2</span><span class="p">))</span>
            <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">],</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_group_pop_var&#39;</span><span class="p">])</span>
            <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">],</span> <span class="n">data_2</span><span class="p">[</span><span class="s1">&#39;pseudo_total_pop&#39;</span><span class="p">])</span>
            
            
            <span class="c1"># Dropping to avoid confusion in the internal function</span>
            <span class="n">data_2_test</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="n">simulations_2</span> <span class="o">=</span> <span class="n">seg_class_2</span><span class="o">.</span><span class="n">_function</span><span class="p">(</span><span class="n">data_2_test</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Dropping to avoid confusion in the next iteration</span>
            <span class="n">data_2</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;fair_coin&#39;</span><span class="p">,</span> <span class="s1">&#39;test_group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;test_total_pop_var&#39;</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="n">est_sim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulations_1</span> <span class="o">-</span> <span class="n">simulations_2</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processed </span><span class="si">{}</span><span class="s1"> iterations out of </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>            
            
            
            
            
    <span class="c1"># Check and, if the case, remove iterations_under_null that resulted in nan or infinite values</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">est_sim</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">est_sim</span><span class="p">))):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some estimates resulted in NaN or infinite values for estimations under null hypothesis. These values will be removed for the final results.&#39;</span><span class="p">)</span>
        <span class="n">est_sim</span> <span class="o">=</span> <span class="n">est_sim</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">est_sim</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">est_sim</span><span class="p">))]</span>

    <span class="c1"># Two-Tailed p-value</span>
    <span class="c1"># Obs.: the null distribution can be located far from zero. Therefore, this is the the appropriate way to calculate the two tailed p-value.</span>
    <span class="n">aux1</span> <span class="o">=</span> <span class="p">(</span><span class="n">point_estimation</span> <span class="o">&lt;</span> <span class="n">est_sim</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">aux2</span> <span class="o">=</span> <span class="p">(</span><span class="n">point_estimation</span> <span class="o">&gt;</span> <span class="n">est_sim</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">aux1</span><span class="p">,</span> <span class="n">aux2</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">est_sim</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">est_sim</span><span class="p">,</span> <span class="n">point_estimation</span><span class="p">,</span> <span class="n">_class_name</span>



<div class="viewcode-block" id="Compare_Segregation"><a class="viewcode-back" href="../../../generated/segregation.inference.Compare_Segregation.html#segregation.inference.Compare_Segregation">[docs]</a><span class="k">class</span> <span class="nc">Compare_Segregation</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform inference comparison for a two segregation measures</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    seg_class_1           : a PySAL segregation object to be compared to seg_class_2</span>
<span class="sd">    </span>
<span class="sd">    seg_class_2           : a PySAL segregation object to be compared to seg_class_1</span>
<span class="sd">    </span>
<span class="sd">    iterations_under_null : number of iterations under null hyphothesis</span>
<span class="sd">    </span>
<span class="sd">    null_approach : argument that specifies which type of null hypothesis the inference will iterate.</span>
<span class="sd">    </span>
<span class="sd">        &quot;random_label&quot;      : random label the data in each iteration</span>
<span class="sd">        </span>
<span class="sd">        &quot;counterfactual_composition&quot; : randomizes the number of minority population according to both cumulative distribution function of a variable that represents the composition of the minority group. The composition is the division of the minority population of unit i divided by total population of tract i.</span>

<span class="sd">        &quot;counterfactual_share&quot; : randomizes the number of minority population and total population according to both cumulative distribution function of a variable that represents the share of the minority group. The share is the division of the minority population of unit i divided by total population of minority population.</span>

<span class="sd">    **kwargs : customizable parameters to pass to the segregation measures. Usually they need to be the same as both seg_class_1 and seg_class_2  was built.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    p_value        : float</span>
<span class="sd">                     Two-Tailed p-value</span>
<span class="sd">    </span>
<span class="sd">    est_sim        : numpy array</span>
<span class="sd">                     Estimates of the segregation measure differences under the null hypothesis</span>
<span class="sd">                  </span>
<span class="sd">    est_point_diff : float</span>
<span class="sd">                     Point estimation of the difference between the segregation measures</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function performs inference to compare two segregation measures. This can be either two measures of the same locations in two different points in time or it can be two different locations at the same point in time.</span>
<span class="sd">    </span>
<span class="sd">    The null hypothesis is H0: Segregation_1 is not different than Segregation_2.</span>
<span class="sd">    </span>
<span class="sd">    Based on Rey, Sergio J., and Myrna L. Sastré-Gutiérrez. &quot;Interregional inequality dynamics in Mexico.&quot; Spatial Economic Analysis 5.3 (2010): 277-298.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Several examples can be found here https://github.com/pysal/segregation/blob/master/notebooks/inference_wrappers_example.ipynb.</span>

<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Compare_Segregation.__init__"><a class="viewcode-back" href="../../../generated/segregation.inference.Compare_Segregation.html#segregation.inference.Compare_Segregation.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_class_1</span><span class="p">,</span> <span class="n">seg_class_2</span><span class="p">,</span> <span class="n">iterations_under_null</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">null_approach</span> <span class="o">=</span> <span class="s2">&quot;random_label&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="n">aux</span> <span class="o">=</span> <span class="n">_compare_segregation</span><span class="p">(</span><span class="n">seg_class_1</span><span class="p">,</span> <span class="n">seg_class_2</span><span class="p">,</span> <span class="n">iterations_under_null</span><span class="p">,</span> <span class="n">null_approach</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_value</span>        <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_sim</span>        <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_point_diff</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_name</span>    <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></div>
        
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Compare_Segregation class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
            <span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method relies on importing `matplotlib` and `seaborn`&#39;</span><span class="p">)</span>
    
        <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_sim</span><span class="p">,</span> 
                     <span class="n">hist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                     <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;darkblue&#39;</span><span class="p">,</span> 
                     <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">:</span><span class="s1">&#39;black&#39;</span><span class="p">},</span>
                     <span class="n">kde_kws</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_point_diff</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> (Diff. value = </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_name</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_point_diff</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>